-- Module which implements the piston in a sphere Chp 12, Mellow & Beranek 2012---
-- )cd ~/Documents/research-repos/bat_beamshapes/bat_beamshapes/workshop/fricas-code/
-- This script was improved greatly by the comments of Ralf Hemmecke and inputs from 
-- Waldek Hebbisch. 

)clear all 
)version
-- setFormat!(FormatMathJax)$JFriCASSupport


-- load the gaussian quadrature routine
)read a_gaussianquad


Z ==> Integer
N ==> NonNegativeInteger
P ==> PositiveInteger
DF ==> DoubleFloat
CDF ==> Complex DF
F ==> Float

-- alpha: the 'aperture' of the piston in radians --
-- R: radius of the sphere in m --
-- NN: index for summations and matrix shape specfication --
-- the formula for NN is from Tim Mellow's Mathematica notebook--

freq := 50000;
k := 2*%pi/(330/freq);
ka := 5 ;
a := ka/k;
alpha := %pi/3::DF;
R:= a/sin(alpha);
R := numeric(R)::DF;
r1 := R*cos(alpha)/cos(theta);
NN :=  3 ;--12 + 2*ka/sin(alpha)--

-- I couldn't find inbuilt spherical bessel's functions, and so had to make custom functions 

-- spherical bessel function-- 
sphBessel(n: N,z: DF): CDF == besselJ(n+0.5,z)*sqrt(%pi/(2*z));
-- spherical neumann function --
sphNeumann(n: N, z: DF): CDF == besselY(n+0.5,z)*sqrt(%pi/(2*z));

sphHankel2(n: N, z: DF): CDF == sphBessel(n,z) - %i*sphNeumann(n,z);


alternate_hankels(n: N,theta: DF): CDF ==   
    r1 := R*cos(alpha)/cos(theta)
    legendreP(n::N,cos(theta))*cos(theta) *( (n-1)*sphHankel2((n-1)::N,k*r1)  - (n+1)*sphHankel2(n+1,k*r1) )

alternate_legendres(n: N, theta: DF): CDF ==
    r1 := R*cos(alpha)/cos(theta)
    n*(n+1)*sphHankel2(n,k*r1)*(legendreP((n-1)::N,cos(theta))-legendreP(n+1,cos(theta)))/(k*r1)

legendretan(m: N, theta: DF): CDF ==
    r1 := R*cos(alpha)/cos(theta)
    legendreP(m,cos(theta))*(r1^2/R^2)*tan(theta)

one_imn_term(m: N, n: N, theta: DF): CDF == 
    r1 := R*cos(alpha)/cos(theta)
    (alternate_hankels(n,theta)+alternate_legendres(m,theta))*legendretan(m,theta)



-- integrate from Imn 0..alpha  for each m,n

max_error := 1.0e-16 -- need to see if this is enough in the future.
max_recursion := 100

imn_mat : Matrix(Complex(DoubleFloat)) := new (NN+1,NN+1,0)

output(".................starting Imn matrix......")
nn_index := [0,1,2,3]
for i in 1..#nn_index repeat
    for j in 1..#nn_index repeat
        output("...starting")
        output(i)
        output(j)
        anon(th) == one_imn_term(nn_index.i::N,nn_index.j::N,th)
        imn_mat(i+1,j+1) := ad_gauss(anon, 0.0::DF, alpha::DF, max_error, max_recursion) 



-- eqn 12.107 --
-- all_kmns := matrix[[legendreP(n,cos(theta))*legendreP(m,cos(theta))*sin(theta) for m in 1..NN] for n in 1..NN ]

-- kmns_mat := [ [integrate(row(all_kmns,m).n, theta=alpha..%pi, "noPole") for m in 1..NN] for n in 1..NN]

-- eqn 12.1081 --
-- all_Lms := [legendreP(m,cos(theta))*(r1^2/R^2) for m in 1..NN]
-- Lm_mat :=  [ integrate(expression, theta=0..alpha,"noPole") for expression in all_Lms]








